import fs from 'fs';
import path from 'path';

import { Vibrant } from 'node-vibrant/node';
import tinify from 'tinify';

import { projectImageMaxWidth } from '@/data/constants';
import { projects as projectsData } from '@/data/projects';
import { tinifyApiKey } from '@/helpers/secrets';

tinify.key = tinifyApiKey;

const inputPath = 'src/helpers/snapshots';
const outputPath = 'src/assets/project-images';
const generatedFilePath = 'src/data/project-images.ts';
const colorsFilePath = 'src/components/project-colors.css';
const originalImageFormat = 'png' as const;
const imageFormat: 'avif' | 'jpeg' | 'png' | 'webp' = 'webp';
const disclaimer = [
  'This file is autogenerated by build-project-images script.',
  'Please do not edit this file manually. Any changes will be overwritten.',
  'To regenerate: npm run build-images',
];
const tsDisclaimer = disclaimer.map((line) => `// ${line}`).join('\n') + '\n\n';
const cssDisclaimer =
  disclaimer.map((line) => `/* ${line} */`).join('\n') + '\n\n';

const getFileName = (key: string) => `${key}-x2.${imageFormat}`;
const getTinyFileName = (key: string) => `${key}-x1.${imageFormat}`;
const chooseColor = async (fromPath: string) => {
  const palette = await Vibrant.from(fromPath).getPalette();
  return palette.Vibrant?.hex || palette.DarkVibrant?.hex;
};

async function buildProjectImages() {
  console.log('ðŸš€ Building project images...');

  // Read PNG files from input directory
  const files = fs
    .readdirSync(inputPath)
    .filter((file) => file.endsWith(`.${originalImageFormat}`));

  if (files.length === 0) {
    console.log(`âŒ No .${originalImageFormat} files found in`, inputPath);
    return;
  }

  const projects: string[] = [];
  const colorSuggestions: string[] = [];

  for (const file of files) {
    // Extract project name from filename (remove extension)
    const projectName = file.replace(`.${originalImageFormat}`, '');
    const fromPath = path.join(inputPath, file);

    console.log(`ðŸ“¸ Processing ${projectName}...`);

    // Extract color from original image
    const color =
      projectName in projectsData
        ? projectsData[projectName as keyof typeof projectsData]
        : await chooseColor(fromPath);

    if (color) {
      colorSuggestions.push(
        `.project-color.${projectName} {\n  --project-color: ${color};\n}`,
      );
      console.log(`ðŸŽ¨ Color selected for ${projectName}: ${color}`);
    } else {
      console.log(`âš ï¸ Could not extract color for ${projectName}`);
    }

    // Convert and compress with Tinify
    try {
      const tinyImage = tinify
        .fromFile(fromPath)
        .convert({ type: `image/${imageFormat}` });

      // Generate regular version (get original dimensions first)
      const regularFileName = getFileName(projectName);
      const regularOutputPath = path.join(outputPath, regularFileName);
      await tinyImage
        .resize({ width: projectImageMaxWidth, method: 'scale' })
        .toFile(regularOutputPath);

      // Generate compressed version with dimension in filename
      const compressedFileName = getTinyFileName(projectName);
      const compressedOutputPath = path.join(outputPath, compressedFileName);
      await tinyImage
        .resize({ width: projectImageMaxWidth / 2, method: 'scale' })
        .toFile(compressedOutputPath);

      console.log(`âœ… Created: ${regularFileName} and ${compressedFileName}`);

      // Track project
      projects.push(projectName);
    } catch (error) {
      console.log(`âŒ Error processing ${projectName}:`, error);
    }
  }

  // Generate TypeScript file
  const imports: string[] = [];
  const projectObjects: string[] = [];
  const urlsObject: string[] = [];

  for (const projectKey of projects) {
    // Generate imports with Src suffix
    const regularFile = getFileName(projectKey);
    const compressedFile = getTinyFileName(projectKey);

    imports.push(
      `import ${projectKey}Src from '/src/assets/project-images/${regularFile}';`,
    );
    imports.push(
      `import ${projectKey}CompressedSrc from '/src/assets/project-images/${compressedFile}';`,
    );

    // Generate project object
    projectObjects.push(
      `const ${projectKey}: ProjectUrls = { src: ${projectKey}Src, compressedSrc: ${projectKey}CompressedSrc };`,
    );

    urlsObject.push(`  '${projectKey}': ${projectKey}`);
  }

  // Generate the complete TypeScript file
  const tsContent = `${tsDisclaimer}export type ProjectUrls = { src: string; compressedSrc: string };

${imports.join('\n')}

${projectObjects.join('\n\n')}

export const urls = {
${urlsObject.join(',\n')},
} as const;

export type ProjectKey = keyof typeof urls;
`;

  // Write the generated file
  fs.writeFileSync(generatedFilePath, tsContent);
  console.log(`âœ… Generated: ${generatedFilePath}`);

  // Write the project colors CSS file
  if (colorSuggestions.length > 0) {
    const cssContent = `${cssDisclaimer}${colorSuggestions.join('\n') + '\n'}`;
    fs.writeFileSync(colorsFilePath, cssContent);
    console.log(`âœ… Generated: ${colorsFilePath}`);
  }

  console.log(`\nâœ¨ Successfully processed ${projects.length} projects`);
}

buildProjectImages().catch(console.error);
